---
title: ブルームフィルタ
title-en: Bloom Filter
---

# 概要

あるデータが集合の要素である（集合に含まれている）かどうかの判定に使われる確率的データ構造。  
空間効率が非常に良いが、**偽陽性**（= 実際には含まれていないのに含まれていると判定）を示す可能性がある。

# 仕組み

以下の図をもとに解説する。

<img width="600" alt="スクリーンショット 2023-09-08 8 05 47" src="https://user-images.githubusercontent.com/13412823/266461090-bbf5889d-e137-480b-9310-075957826f56.png">


## 1. 準備（フィルタの作成・初期化）

- 全ての値がゼロで初期化された、長さ $m$ のビット配列
- データ $d$ を入力として、0以上 $m-1$ 以下のハッシュ値を出力する $k$ 個のハッシュ関数 $h_1(d), h_2(d), \cdots, h_k(d)$

を用意する。図は $m=20,\ k=2$ の場合。

## 2. データの追加 (add)

1. 追加したいデータ $d$ のハッシュ値 $h_1(d), h_2(d), \cdots, h_k(d)$ を計算
2. ビット配列の $h_1(d), h_2(d), \cdots, h_k(d)$ 番目の値を0→1に変更
    1. 元々1だった場合は何も変えない

図の上半分は data 1〜3（$d_1, d_2, d_3$）を追加する例。  
計算されたハッシュ値が
- $h_1(d_1)=6,\ h_2(d_1)=9$
- $h_1(d_2)=16,\ h_2(d_2)=2$
- $h_1(d_3)=6,\ h_2(d_3)=13$

だったので、配列の $2,6,9,13,16$ 番目の値を1に変えている。

## 3. データの検索 (search)

1. 検索したいデータ $d$ のハッシュ値 $h_1(d), h_2(d), \cdots, h_k(d)$ を計算
2. ビット配列の $h_1(d), h_2(d), \cdots, h_k(d)$ 番目の値が「全て1」だったら「存在する」と判定

図の下半分は、data 1〜3 を追加した後、data 1,4,5（$d_1, d_4, d_5$）が存在するかどうか検索する例。

- data 1：真陽性, True Positive
    - 実際に存在するデータを「存在する」と判定できる
- data 4：真陰性, True Negative
    - 実際に存在しないデータを「存在しない」と判定できる
- data 5：**偽陽性, False Positive**
    - **実際には存在しないデータを「存在する」と判定してしまう**

偽陽性を示す原因は、ハッシュ値の衝突（別データなのに同じハッシュ値を出力）。  
しかも複数のハッシュ関数で1つの配列を共有するため、別データに対する別ハッシュ関数の値が衝突しただけでも偽陽性を示す可能性がある。  
data 5 はまさにその例であり、$h_1(d_5) = h_2(d_3) = 9,\ h_2(d_5) = h_1(d_2) = 16$ という衝突が起こっている。


> **【NOTE】疑問：なぜ複数のハッシュ関数で共通の1つの配列を使うのか？**
> 
> - 無駄にハッシュ値の衝突確率が上がるし、仕組みの理解が複雑にならないか？
> - $k$ 個のハッシュ関数それぞれに対応する長さ $m$ の別の配列を作って、$m \times k$ 行列でフラグを立てれば良いのでは？
> - 多少衝突確率が上がっても可能な限り空間計算量を少なくしたい、というモチベーション？
> 
> [StackOverflow の質問と回答](https://stackoverflow.com/questions/49139960/why-bloom-filters-use-the-same-array-for-all-k-hashing-algorithms)：  
> ハッシュ関数の個数 $k$ が配列長 $m$ より十分に小さければ問題にならない、とのこと。  
> 確かにそうだと思うが、よっぽど $k$ が大きくない限り、別に複数の配列を使ってもそれほど気にするほどの空間計算量にはならない気がする。


# 用途

前述の通り、Bloom Filter は偽陽性を示す可能性がある。  
そのため、「集合内に **確実に** データが存在する」という判定ではなく、「集合内にデータが存在する **可能性がある（高い）**」という判定で十分に役立つようなシステムに利用される。

また、Bloom Filter の配列が密（値に1が多い）だと偽陽性の可能性が高くなるので、扱いたいデータ量に応じて、十分に疎となるような配列サイズを確保することが望ましい。

- [Cassandra](../../OSS/cassandra.md) など分散 DB
    - DB 内の全レコードに関する存在判定用の Bloom Filter を各サーバが持つ
        - 全レコードそのものを1つのサーバが持つことは無理でも、そのハッシュ値をインデックスとする配列であれば非常にサイズを小さくでき、1つのサーバでも持てる
    - 分散 DB なので、あるサーバ A がデータ $d$ について検索リクエストを受けたとき、DB 全体で見れば $d$ が存在していても、リクエストを受けた A 自身は $d$ を持っていない可能性がある
    - 他のサーバ B, C, D, ... に「データ $d$ を持っていますか？」という確認通信をすれば良いが、通信コストがかかる
    - なのでまずは A 自身が持つ Bloom Filter を参照し、**「データが存在する可能性がある」ときだけ他サーバに問い合わせて「本当に存在するかどうか？」を確認**

# 実装

- 空間効率を考えるとフィルタには純粋な $m$ ビット整数を使うのが良いが、ここでは動作を理解しやすくするため $m$ 次元配列を使う
- 実際とは異なるが、複数のハッシュ関数に対し、それぞれ専用の配列を用意して、別ハッシュ関数のハッシュ値が衝突しないように実装する

{% gist 099780657962f1a7205d4b5259734a3c 20230907_bloom-filter.py %}

# 実験

## BloomFilter に登録済みの検索単語の割合を変える

![Figure_1](https://user-images.githubusercontent.com/13412823/266193182-747763e9-22fd-4f0d-979c-e79eff43eaa1.png)

- 確率的にハッシュ関数の衝突が起こり、偽陽性（BloomFilter に登録されたことがない単語に対して「存在する」と判定）を示す
- 登録済み単語が非常に少ない時：BloomFIlter は非常に疎であり、ハッシュ値の衝突が起こる頻度が非常に少ないため偽陽性率は低い
- 登録済み単語が非常に多い時：実際に登録済みの単語がほとんどであり、未登録単語が検索される回数自体が非常に少なく偽陽性率が低い

実験コード：

{% gist 099780657962f1a7205d4b5259734a3c ~1_word-add-rate.py %}


## フィルタのサイズを変える

![Figure_2](https://user-images.githubusercontent.com/13412823/266193191-07527904-c323-41bd-9171-76a25e57d4e2.png)

- フィルタのサイズが大きいほど、ハッシュ値がとりうる値が多いので、ハッシュ値の衝突が発生しにくくなって偽陽性率が下がる

実験コード：

{% gist 099780657962f1a7205d4b5259734a3c ~2_filter-size.py %}


## ハッシュ関数の個数を変える

![Figure_3](https://user-images.githubusercontent.com/13412823/266193197-563ee24f-51a4-4527-8620-9a0c2060003d.png)

- 偽陽性となるのは、「別単語に複数のハッシュ関数を適用した時、ハッシュ値が全て衝突する」とき
- なので使用するハッシュ関数を多くすると、BloomFilter がそれなりに密（実験ではサイズ10000のフィルタに2000単語を追加）であっても、大きく偽陽性率が下がる

実験コード：

{% gist 099780657962f1a7205d4b5259734a3c ~3_num-of-hash.py %}