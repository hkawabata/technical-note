---
title: Web API The Good Parts
main_image: https://user-images.githubusercontent.com/13412823/50417465-d33ba300-0869-11e9-9a43-3cec04ed70f7.jpg
---

# 1章 Web API とは何か

## API の公開を検討する

- **API エコノミー**: Web API を広く公開することで外部サービスとの連携が容易になり、新しい価値が生まれてサービスやビジネスが発展していくこと
- [Programable Web](https://www.programmableweb.com/): 様々な API の情報を収集・公開する API ディレクトリサービス
- 何を公開すべきか？
    - そのサービスができること（コアの価値ある部分）全て
- 公開によって得られるもの
    - 他の企業や個人が付加価値を提供してくれる  
      → それが有用であれば自分たちで同じ機能を用意することも可能

## API 設計の観点

- **使いやすい**
    - 使ってほしいから公開するのに使いづらい API にしてしまっては意味が薄れる
- **変更しやすい**
    - システムは進化していくので、API も変更を余儀なくされる
    - ユーザに影響を与えることなく API 変更を行うという観点も含む
- **頑強である**
    - セキュリティ面が考慮されている
- **恥ずかしくない**
    - ウェブサービスとは異なり、API を目にするのは主に技術者
    - ダサい API を公開していると技術力が疑われる恐れも

## API 設計の原則

- 仕様が決まっているものは仕様に従う
- 仕様が決まっていないものはデファクトスタンダードに従う

## 「REST」

- 本書では REST の考え方を適用する場面が多いものの、厳密な REST の定義にはこだわらない

## 対象開発者の分類

| 分類 | 説明 |
| :-- | :-- |
| **LSUD** (Large Set of Unknown Developers) | Facebook や Twitter など、誰でも使えるパブリックな API のユーザ |
| **SSKD** (Small Set of Known Developers) | 自社サービスのクライアントアプリ向けの API など、利用者が限られた API のユーザ |

LSUD 向けか SSKD 向けかで設計の思想は異なるはず。


# 2章 エンドポイントの設計とリクエストの形式

1. API で提供する機能を決定
2. エンドポイント（API にアクセスするための URI）を設計
    - URI 設計: **覚えやすく、どんな機能を持つのかひと目で分かるものにする**
        - 短く入力しやすい（ドメイン名も含めて、無駄に同じ意味を重複させない）
        - 人間が読んで理解できる
            - むやみに省略形を使わない
            - API によく使われる単語を使う
        - 大文字小文字を混在させない
        - 改造しやすい（Hackable）ようにする
            - ある程度、仕様書を見なくとも別の URI の作り方が類推できる
            - ex. http://api.example.com/v1/users/1234
        - サーバ側のアーキテクチャを反映しない
            - アンチパターン: http://api.example.com/cgi-bin/get_user.php
        - 複数機能を別のエンドポイントで提供する際はルールを統一する
    - 利用する HTTP メソッドも合わせて設計する

## エンドポイント設計の注意点

- 「複数形」の「名詞」を使う
    - ex. `user`→`users`,`friend`→`friends`
    - URI はリソースを表すものという考え方から、動詞は極力入れないのが基本
    - 慣習的に`search`のように動詞が使われるケースもある
- 空白やエンコードを必要とする文字を使わない
- 単語を繋げる必要がある場合はハイフンを使うのがベター
    - 厳密なルールはないので最終的にはプロダクトのポリシーや好み次第
    - そもそも、繋ぎ合わせずパスを区切ったりクエリパラメータに分離したりする方が見やすくなることが多い

## クエリパラメータとパスの使い分け

- 一意なリソースを表すのに必要な情報ならパスに含め、そうでなければクエリパラメータに
- 省略可能な情報ならクエリパラメータに

## ログイン

- 仕様としては OAuth が標準的

```
                   +--------------+
   +------(3)----->|    App A     |
   |  +---(4)------| (ex.Twitter) |
   |  |   token    +--------------+
   |  v                 ^    |
+--------+              |    |
|  user  |       token (6)  (7) resource
+--------+              |    |
   | ^ |                |    v
   | | |           +--------------+
   | | +--(1)----->|    App B     |
   | +----(2)------| (use App1    |
   +------(5)----->|  resources)  |
          token    +--------------+
```

1. App A のリソースへのアクセスしてください
2. では App A のアクセス許可をもらってください
3. App B がリソースへアクセスするのを許可します
4. ではこのトークンを App B に渡してください
5. このトークンを使って App A からリソースを取得してください
6. リソースをください
7. どうぞ


## HATEOAS と REST LEVEL3 API

Martin Fowler による「REST API の設計レベル」(2010)

| LEVEL | 内容 |
| :-- | :-- |
| 0 | HTTP を使っている |
| 1 | リソースの概念の導入 |
| 2 | HTTP の動詞（GET/POST/PUT/DELETE/...）の導入 |
| 3 | HATEOAS の概念の導入 |

**HATEOAS** (Hypermedia As The Engine Of Application State) の思想:

- API が返却するデータの中に、次に行う行動、取得するデータ等の URI をリンクとして埋め込んでおく
- これにより、データを見れば次にどのエンドポイントにアクセスすれば良いかがひと目で分かる

```json
{
  "friends": [
    {
      "name": "Taro",
      "link": {
        "uri": "https://api.example.com/v1/users/12345",
        "rel": "user/detail"
      }
    },
    {
      "name": "Jiro",
      "link": {
        "uri": "https://api.example.com/v1/users/13558",
        "rel": "user/detail"
      }
    }
  ]
}
```

REST LEVEL3 のメリット:

- 入口となる最初の API エンドポイントさえ分かっていれば、その先の操作を行うためのエンドポイントは API レンスポンスが教えてくれる
- よって、変更から配布までに時間がかかるクライアントアプリケーションなどにおいては、URI を変更するたびにクライアント側を修正する、あるいは通知するといった手間が不要になる


# 3章 レスポンスデータの設計

## データフォーマット

主流である JSON に対応していれば基本的に問題はない

- Amazon のように XML しかサポートしていないところも
- Yahoo! Japan などは PHPserialize にも対応

![](https://user-images.githubusercontent.com/13412823/52910340-814b5280-32d9-11e9-8858-6c7f9c1ce710.png)


複数データフォーマットに対応している場合の指定方法

- クエリパラメータで指定
- URI の最後に拡張子を付与（ex. `http://api.example.com/users.json`）
- リクエストヘッダでメディアタイプを指定

`format`などのクエリパラメータによる指定が多数派。

## JSONP

- 同一生成元ポリシーによる制約を回避するためのテクニック
- セキュリティ上のリスクを抱えるため、最低限必要な箇所だけ利用すべき


## データの内部構造の考え方

- **Chatty API**
    - 1つの作業を完了するために複数回のアクセスが必要な API





